<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dr.&nbsp;Jean-Christophe Loiseau">
<meta name="dcterms.date" content="2025-09-23">
<meta name="description" content="Quarto Academic Website Template adapted by Dr.&nbsp;Gang He">

<title>Jacobi method: From a naïve implementation to a modern Fortran multithreaded one – Dr.&nbsp;Jean-Christophe Loiseau</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7ffecba3d65d0ceb76f4c7db622b63c9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ee646ce384f049f4eccff96e17073bcf.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1GNWFLTF2M"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-1GNWFLTF2M', { 'anonymize_ip': true});
</script>

<!-- 
Load Academicons v1: https://jpswalsh.github.io/academicons/
-->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">

<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


<!---
The following code are needed to show dimension citation and altmetrics.
https://api.altmetric.com/embeds.html
https://badge.dimensions.ai/
--->

<script type="text/javascript" src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>

<script async="" src="https://badge.dimensions.ai/badge.js" charset="utf-8"></script>

<script type="text/javascript" src="//cdn.plu.mx/widget-popup.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Jacobi method: From a naïve implementation to a modern Fortran multithreaded one – Dr.&nbsp;Jean-Christophe Loiseau">
<meta property="og:description" content="Quarto Academic Website Template adapted by Dr.&nbsp;Gang He">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Fortran_acs_cover.jpeg/250px-Fortran_acs_cover.jpeg">
<meta property="og:site_name" content="Dr. Jean-Christophe Loiseau">
<meta name="twitter:title" content="Jacobi method: From a naïve implementation to a modern Fortran multithreaded one – Dr.&nbsp;Jean-Christophe Loiseau">
<meta name="twitter:description" content="Quarto Academic Website Template adapted by Dr.&nbsp;Gang He">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Fortran_acs_cover.jpeg/250px-Fortran_acs_cover.jpeg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Dr.&nbsp;Jean-Christophe Loiseau</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../../posts.html#category=news">
 <span class="dropdown-text">News</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts.html#category=event">
 <span class="dropdown-text">Events</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../contact.html">
 <span class="dropdown-text">Contact</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-research" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Research</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-research">    
        <li>
    <a class="dropdown-item" href="../../publications.html">
 <span class="dropdown-text">List of Publications</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts.html#category=paper">
 <span class="dropdown-text">Selected Papers</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../projects.html">
 <span class="dropdown-text">Grants</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-outreach" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Outreach</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-outreach">    
        <li>
    <a class="dropdown-item" href="../../posts.html#category=presentation">
 <span class="dropdown-text">Presentations</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../people.html"> 
<span class="menu-text">Group</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html#category=blog"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../files/nsf-biosketch.pdf"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/loiseaujc" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://bsky.app" target="_blank"> 
<span class="menu-text"><i class="fa-brands fa-bluesky" aria-label="bluesky"></i></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../posts.xml" target="_blank"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#solving-a-linear-system-with-the-jacobi-method" id="toc-solving-a-linear-system-with-the-jacobi-method" class="nav-link active" data-scroll-target="#solving-a-linear-system-with-the-jacobi-method">Solving a linear system with the Jacobi method?</a>
  <ul class="collapse">
  <li><a href="#a-brief-overview" id="toc-a-brief-overview" class="nav-link" data-scroll-target="#a-brief-overview">A brief overview</a></li>
  <li><a href="#fair-enough-but-does-it-actually-converge" id="toc-fair-enough-but-does-it-actually-converge" class="nav-link" data-scroll-target="#fair-enough-but-does-it-actually-converge">Fair enough, but does it actually converge?</a></li>
  <li><a href="#alright-it-converges.-but-how-fast" id="toc-alright-it-converges.-but-how-fast" class="nav-link" data-scroll-target="#alright-it-converges.-but-how-fast">Alright, it converges. But how fast?</a></li>
  </ul></li>
  <li><a href="#the-poissons-equation-on-the-unit-square" id="toc-the-poissons-equation-on-the-unit-square" class="nav-link" data-scroll-target="#the-poissons-equation-on-the-unit-square">The Poisson’s equation on the unit square</a>
  <ul class="collapse">
  <li><a href="#discretizing-the-problem" id="toc-discretizing-the-problem" class="nav-link" data-scroll-target="#discretizing-the-problem">Discretizing the problem</a></li>
  <li><a href="#the-jacobi-method-for-the-2d-poisson-equation" id="toc-the-jacobi-method-for-the-2d-poisson-equation" class="nav-link" data-scroll-target="#the-jacobi-method-for-the-2d-poisson-equation">The Jacobi method for the 2D Poisson equation</a></li>
  </ul></li>
  <li><a href="#let-fortran-shine" id="toc-let-fortran-shine" class="nav-link" data-scroll-target="#let-fortran-shine">Let <code>Fortran</code> shine!</a>
  <ul class="collapse">
  <li><a href="#baseline-implementation" id="toc-baseline-implementation" class="nav-link" data-scroll-target="#baseline-implementation">Baseline implementation</a></li>
  <li><a href="#you-shall-not-copy" id="toc-you-shall-not-copy" class="nav-link" data-scroll-target="#you-shall-not-copy">You shall not copy!</a></li>
  <li><a href="#further-optimizations" id="toc-further-optimizations" class="nav-link" data-scroll-target="#further-optimizations">Further optimizations</a></li>
  <li><a href="#multithreaded-performances" id="toc-multithreaded-performances" class="nav-link" data-scroll-target="#multithreaded-performances">Multithreaded performances</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Jacobi method: From a naïve implementation to a modern Fortran multithreaded one</h1>
  <div class="quarto-categories">
    <div class="quarto-category">blog</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jean-Christophe Loiseau </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 23, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>In a previous <a href="https://loiseaujc.github.io/posts/blog-title/fortran_vs_python.html">post</a>, I used the Jacobi method to illustrate some merits of <code>Fortran</code> over <code>Python</code> for teaching purposes. Since then, I received a handful of messages asking how to write efficient <code>Fortran</code> code. Because of its algorithmic simplicity, the Jacobi method makes for an excellent case study. In this post, we’ll see how to go from a naïve implementation taking a minute to solve a linear system with a quarter million unknowns to a multithreaded version taking less 3 seconds. Bonus point: the code is entirely standard-compliant and you don’t need to know anything about <a href="https://www.openmp.org/">OpenMP</a> or <a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">MPI</a>. If you want to see the whole code, check <a href="https://github.com/loiseaujc/Jacobi-Experiments">this</a> GitHub repo. But first, what is the Jacobi method?</p>
<section id="solving-a-linear-system-with-the-jacobi-method" class="level2">
<h2 class="anchored" data-anchor-id="solving-a-linear-system-with-the-jacobi-method">Solving a linear system with the Jacobi method?</h2>
<p>Consider the system of linear equations</p>
<p><span class="math display">\[
\mathbf{Ax} = \mathbf{b},
\]</span></p>
<p>where <span class="math inline">\(\mathbf{A}\)</span> is an invertible <span class="math inline">\(n \times n\)</span> matrix. If you ever had a course on numerical linear algebra, you have seen various algorithms to solve this problem. These are divided in two categories: direct solvers targetting small- to medium-sized dense matrices, and iterative solvers for large sparse matrices.</p>
<p>Among the zoo of iterative methods, the <a href="https://en.wikipedia.org/wiki/Jacobi_method">Jacobi method</a> is probably the first one you’ve encountered. There are two reasons for that:</p>
<ol type="1">
<li>It is easy to implement, no matter the programming language.</li>
<li>Its theoretical analysis is rather simple, even for undergrad students.</li>
</ol>
<p>It does come with its limitations though: it does not work for all possible matrices and the convergence is rather slow (i.e.&nbsp;it requires many iterations). Because of these, the Jacobi method is not a viable alternative compared to the (preconditioned) <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">conjugate gradient</a> or <a href="https://en.wikipedia.org/wiki/Multigrid_method">multigrid</a> methods and is thus hardly used in production codes. It is however, in my opinion, a fantastic learning example. So, how does it work?</p>
<section id="a-brief-overview" class="level3">
<h3 class="anchored" data-anchor-id="a-brief-overview">A brief overview</h3>
<p>The Jacobi method relies on the additive decomposition:</p>
<p><span class="math display">\[\mathbf{A} = \mathbf{D} + \mathbf{R},\]</span></p>
<p>where <span class="math inline">\(\mathbf{D}\)</span> is the diagonal component of <span class="math inline">\(\mathbf{A}\)</span>, and <span class="math inline">\(\mathbf{R}\)</span> consists of the off-diagonal terms. Plugging this decomposition into our system leads to</p>
<p><span class="math display">\[
\mathbf{Dx} + \mathbf{Rx} = \mathbf{b}.
\]</span></p>
<p>Starting from an initial guess <span class="math inline">\(\mathbf{x}_0\)</span>, the core idea of the Jacobi method is to treat the diagonal contributions <em>implicitly</em> and the off-diagonal ones <em>explicitly</em>, analoguous to a time-integration scheme. This leads to the following iterative scheme</p>
<p><span class="math display">\[
\mathbf{x}_{t+1} = \mathbf{D}^{-1} \left( \mathbf{b} - \mathbf{Rx}_t \right),
\]</span></p>
<p>where subscript <span class="math inline">\(t\)</span> denotes the <span class="math inline">\(t\)</span>-th iteration of the method. What we claim then is that, under suitable assumptions on <span class="math inline">\(\mathbf{A}\)</span>, the iterate <span class="math inline">\(\mathbf{x}_t\)</span> converges to the actual solution of the system as <span class="math inline">\(t \to \infty\)</span>. So when does it converge? And if so, how fast does it converge?<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
</section>
<section id="fair-enough-but-does-it-actually-converge" class="level3">
<h3 class="anchored" data-anchor-id="fair-enough-but-does-it-actually-converge">Fair enough, but does it actually converge?</h3>
<p>The questions of whether or not an iterative method converges and, if so, how fast does it converge are obviously critical to assess its competitiveness. To answer to both of these questions, let us rewrite the Jacobi iteration as</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{x}_{t+1}    &amp;   = \mathbf{x}_t - \mathbf{D}^{-1} \left( \mathbf{b} - \mathbf{Ax}_t \right) \\
                    &amp;   = \left( \mathbf{I} - \mathbf{D}^{-1}\mathbf{A} \right) \mathbf{x}_t - \mathbf{D}^{-1} \mathbf{b}.
\end{aligned}
\]</span></p>
<p>To derive this expression, simply add and subtract <span class="math inline">\(\mathbf{Dx}_t\)</span> inside the parenthesized term in the right-hand side and group terms together. Now, let <span class="math inline">\(\mathbf{x}_{\star}\)</span> be the true solution of the system, i.e.&nbsp;<span class="math inline">\(\mathbf{x}_{\star} = \mathbf{A}^{-1} \mathbf{b}\)</span>, and <span class="math inline">\(\mathbf{e}_t = \mathbf{x}_t - \mathbf{x}_{\star}\)</span> be the error at iteration <span class="math inline">\(t\)</span>. Using simple algebraic manipulations, the dynamics of the error vector are governed by</p>
<p><span class="math display">\[
\mathbf{e}_{t+1} = \left(\mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \right) \mathbf{e}_t.
\]</span></p>
<p>Obviously, the Jacobi method converges to the correct solution provided <span class="math inline">\(\displaystyle \lim_{t \to \infty} \| \mathbf{e}_t \| = 0\)</span> where <span class="math inline">\(\| \cdot \|\)</span> is a suitable vector norm. The question of its convergence thus reduces to: under what condition on <span class="math inline">\(\mathbf{I} - \mathbf{D}^{-1} \mathbf{A}\)</span> does the norm of the error vector goes to zero?</p>
<blockquote class="blockquote">
<p><strong>Theorem n°1 –</strong> The Jacobi iterative method</p>
<p><span class="math display">\[\mathbf{x}_{t+1} = \left( \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \right) \mathbf{x}_t - \mathbf{D}^{-1}\mathbf{b}\]</span></p>
<p>converges for any initial vector <span class="math inline">\(\mathbf{x}_0\)</span> provided <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \| &lt; 1\)</span> where <span class="math inline">\(\| \cdot \|\)</span> is a matrix norm induced by the corresponding vector norm.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Sketch of the proof –</strong> Let <span class="math inline">\(\| \cdot \|\)</span> be a matrix norm consistent with a vector norm. Then</p>
<p><span class="math display">\[\| \mathbf{e}_{t+1} \| = \| \left( \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \right) \mathbf{e}_t \| \leq \| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \| \cdot \| \mathbf{e}_t \|.\]</span></p>
<p>A simple inductive argument shows that (for <span class="math inline">\(t\)</span> large enough)</p>
<p><span class="math display">\[\| \mathbf{e}_t \| \leq \| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \|^t \cdot \| \mathbf{e}_0 \|.\]</span></p>
<p>Hence, <span class="math inline">\(\| \mathbf{e}_t \|\)</span> converges to zero as <span class="math inline">\(t \to \infty\)</span> for all <span class="math inline">\(\mathbf{e}_0\)</span> provided that <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \| &lt; 1\)</span>.</p>
</blockquote>
<p>Alright, we now know the Jacobi method converges provided <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \| &lt; 1\)</span>. But what are the necessary and/or sufficient conditions on <span class="math inline">\(\mathbf{A}\)</span> for <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \|\)</span> to be less than unity?</p>
<blockquote class="blockquote">
<p><strong>Theorem n°2 –</strong> Let <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(2\mathbf{D} - \mathbf{A}\)</span> be symmetric positive definite matrices. Then, the Jacobi iteration converges.</p>
</blockquote>
<p>The proof is divided in two parts.</p>
<blockquote class="blockquote">
<p><strong>Proof (part 1) –</strong> Let <span class="math inline">\(\mathbf{A}\)</span> be symmetric positive definite and <span class="math inline">\(\mu\)</span> be an eigenvalue of <span class="math inline">\(\mathbf{I} - \mathbf{D}^{-1} \mathbf{A}\)</span> with eigenvector <span class="math inline">\(\mathbf{v}\)</span>. Then <span class="math display">\[ \left( \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \right) \mathbf{v} = \mu \mathbf{v}.\]</span> Mutliplying from the left by <span class="math inline">\(\mathbf{D}^{-1}\)</span> leads to <span class="math display">\[ \left( \mathbf{D} - \mathbf{A} \right) \mathbf{v} = \mu \mathbf{Dv}.\]</span> Then <span class="math display">\[ \mathbf{v}^T \left( \mathbf{D} - \mathbf{A} \right) \mathbf{v} = \mu \mathbf{v}^T \mathbf{Dv}.\]</span> Re-arranging terms yields <span class="math display">\[ \left(1 - \mu \right) \mathbf{v}^T \mathbf{Dv} = \mathbf{v}^T \mathbf{Av}.\]</span> <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{D}\)</span> being symmetric positive definite, we have <span class="math display">\[ \mathbf{v}^T \mathbf{Av} &gt; 0 \quad \text{and} \quad \mathbf{v}^T \mathbf{Dv} &gt; 0.\]</span> It implies <span class="math inline">\(\left( 1 - \mu \right) &gt; 0\)</span> and thus <span class="math inline">\(\mu &lt; 1\)</span>. Hence, all the eigenvalues <span class="math inline">\(\mu\)</span> of <span class="math inline">\(\mathbf{I} - \mathbf{D}^{-1} \mathbf{A}\)</span> are less than unity.</p>
</blockquote>
<p>While we arrived at the conclusion that <span class="math inline">\(\mu &lt; 1\)</span>, nothing so far implies <span class="math inline">\(-1 &lt; \mu\)</span> and thus <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \| &lt; 1\)</span>. This is where the condition on <span class="math inline">\(2\mathbf{D} - \mathbf{A}\)</span> comes into play.</p>
<blockquote class="blockquote">
<p><strong>Proof (part 2) –</strong> Let <span class="math inline">\(2\mathbf{D} - \mathbf{A}\)</span> be symmetric positive definite. Then <span class="math display">\[\mathbf{v}^T \left( 2\mathbf{D} - \mathbf{A} \right) \mathbf{v} &gt; 0\]</span> and thus <span class="math display">\[\mathbf{v}^T \left( \mathbf{D} - \mathbf{A} \right) \mathbf{v} &gt; - \mathbf{v}^T \mathbf{Dv}.\]</span> From part 1, we know that <span class="math inline">\(\mathbf{v}^T \left( \mathbf{D} - \mathbf{A} \right) \mathbf{v} = \mu \mathbf{v}^T \mathbf{Dv}\)</span>. Hence <span class="math display">\[\mu \mathbf{v}^T \mathbf{Dv} &gt; - \mathbf{v}^T\mathbf{Dv}\]</span> implying <span class="math inline">\(-1 &lt; \mu\)</span>. Combined with part 1, we thus have <span class="math inline">\(-1 &lt; \mu &lt; 1\)</span>, i.e.&nbsp;the eigenvalues of <span class="math inline">\(\mathbf{I} - \mathbf{D}^{-1}\mathbf{A}\)</span> are inside the unit circle (and real) and the Jacobi iteration converges.</p>
</blockquote>
<p>Note that the condition “<span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(2\mathbf{D} - \mathbf{A}\)</span> being symmetric positive definite” is sufficient although not necessary to guarantee the convergence of the Jacobi method. Another classical sufficient but non-necessary condition is that <span class="math inline">\(\mathbf{A}\)</span> is strictly row diagonally dominant. Again, it is relatively easy to prove but since I’m the teacher here, I’ll end this theoretical analysis with the nefarious: <em>This is left as an exercise for the reader.</em></p>
</section>
<section id="alright-it-converges.-but-how-fast" class="level3">
<h3 class="anchored" data-anchor-id="alright-it-converges.-but-how-fast">Alright, it converges. But how fast?</h3>
<p>We’ve actually already partially answered this question. From the sketch of the proof for Theorem n°1, we have</p>
<p><span class="math display">\[
\| \mathbf{e}_t \| \leq \| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \|^t \cdot \| \mathbf{e}_0 \|.
\]</span></p>
<p>Obviously, the smaller <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \|\)</span>, the faster the convergence. And we know that <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \| &lt; 1\)</span> is related to the eigenvalues of the iteration matrix being inside the unit circle. So how do the eigenvalues influence the convergence rate of the method?</p>
<p>A useful quantity to estimate the convergence rate of the method is the <a href="https://en.wikipedia.org/wiki/Spectral_radius">spectral radius</a> of the iteration matrix <span class="math inline">\(\mathbf{M} = \mathbf{I} - \mathbf{D}^{-1} \mathbf{A}\)</span>. It is defined as</p>
<p><span class="math display">\[
\rho(\mathbf{M}) = \max \left\{ \vert \mu_1 \vert, \cdots, \vert \mu_n \vert \right\},
\]</span></p>
<p>where <span class="math inline">\(\mu_i\)</span> are the eigenvalues. Moreover, <span class="math inline">\(\rho(\mathbf{M}) \leq \| \mathbf{M} \|\)</span> for every natural matrix norms. From our previous discussion, we know that <span class="math inline">\(\rho(\mathbf{M}) &lt; 1\)</span> since the Jacobi method converges. Eventhough the spectral radius is only a lower bound for <span class="math inline">\(\| \mathbf{I} - \mathbf{D}^{-1} \mathbf{A} \|\)</span>, we’ll assume for the sake of simplicity that it is pretty tight. Hence, we roughly have</p>
<p><span class="math display">\[
\| \mathbf{e}_t \| \leq \rho(\mathbf{M})^t \cdot \| \mathbf{e}_0 \|.
\]</span></p>
<p>We could make this statement more formal but it wouldn’t change the intuition: the smaller the spectral radius, the larger the asymptotic convergence rate. Unfortunately, there is not much else to say without knowing exactly the matrix <span class="math inline">\(\mathbf{A}\)</span> so let’s turn to the actual problem of interest of this post.</p>
</section>
</section>
<section id="the-poissons-equation-on-the-unit-square" class="level2">
<h2 class="anchored" data-anchor-id="the-poissons-equation-on-the-unit-square">The Poisson’s equation on the unit square</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Poisson%27s_equation">Poisson’s equation</a> is an elliptic partial differential equation (PDE) appearing in numerous fields of physics. Let’s parse what this means:</p>
<ul>
<li><strong>PDE –</strong> The solution of the equation depends on more than one variable, where the variables are typically the different spatial dimensions.</li>
<li><strong>Elliptic –</strong> The solution exhibits a certain notion of smoothness, whatever that means mathematically. Typically, it implies that the solution will not exhibit any discontinuities or very steep fronts in contrast to what you may see for hyperbolic equations (think shock waves for instance).</li>
</ul>
<p>Mathematically, it reads</p>
<p><span class="math display">\[
\nabla^2 u = -f,
\]</span></p>
<p>along with appropriate boundary conditions. In the rest of this post, we’ll consider one of its simplest variations. The domain <span class="math inline">\(\Omega\)</span> is the unit square, i.e.&nbsp;<span class="math inline">\(\Omega = \left[0, 1 \right]^2\)</span> and we will consider only homogenous Dirichlet boundary conditions, i.e.&nbsp;<span class="math inline">\(u = 0\)</span> on the boundaries of the square. Our problem thus is</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
    \dfrac{\partial^2 u}{\partial x^2} + \dfrac{\partial^2 u}{\partial y^2} = -f \quad &amp; \text{for } (x, y) \in \Omega \\
    u(x, y) = 0 \quad &amp; \text{for } (x, y) \in \partial \Omega.
\end{aligned}
\right.
\]</span></p>
<p>Note that the problem is sufficiently simple that you can express its analytical solution using Fourier series. But we are computational scientists, so we’ll solve the problem numerically.</p>
<section id="discretizing-the-problem" class="level3">
<h3 class="anchored" data-anchor-id="discretizing-the-problem">Discretizing the problem</h3>
<p>There are many different ways to discretize a partial differential equation. Finite differences, finite volumes, finite elements, spectral elements, spectral methods, pseudo-spectral methods, etc. There are no silver bullets though. Each has its pros and cons. At the end of the day, the discretization method used is often a matter of personal preferences. To keep things simple, we will consider the standard second-order accurate finite-difference scheme. We will also consider a uniform grid spacing in each direction so that our differential operators can be approximated as</p>
<p><span class="math display">\[
\dfrac{\partial^2 u}{\partial x^2} \simeq \dfrac{u_{i+1, j} - 2u_{i, j} + u_{i-1, j}}{\Delta x^2}
\quad \text{and} \quad
\dfrac{\partial^2 u}{\partial y^2} \simeq \dfrac{u_{i, j+1} - 2u_{i, j} + u_{i, j-1}}{\Delta y^2}
\]</span></p>
<p>where <span class="math inline">\(\Delta x\)</span> and <span class="math inline">\(\Delta y\)</span> are the grid sizes in each direction, and <span class="math inline">\(u_{i, j}\)</span> is the value of our unknown function evaluated at the grid point <span class="math inline">\((x_i, y_j) = (i \Delta x, j \Delta y)\)</span>. For the sake of simplicity, we’ll assume furthermore that <span class="math inline">\(\Delta x = \Delta y\)</span>. Our discretized partial differential equation for points inside of the domain then reads</p>
<p><span class="math display">\[
\dfrac{1}{\Delta x^2} \left( u_{i+1, j} + u_{i-1, j} + u_{i, j+1} + u_{i, j-1} - 4 u_{i, j} \right) = -f_{i, j}.
\]</span></p>
<p>It may not seem like a linear system, but trust me, it is. The field <span class="math inline">\(u(x, y)\)</span> is represented as a two-dimensional array (and I mean <em>array</em>, not <em>matrix</em>) for the sake of simplicity. But you can always represent it as a vector by simply stacking the columns of the array on top of one another, and likewise for the right-hand side forcing <span class="math inline">\(f(x, y)\)</span>.</p>
<p>So, where is the matrix then? Consider a single column of the array <span class="math inline">\(u\)</span>, that is we fix <span class="math inline">\(x\)</span> and only consider different <span class="math inline">\(y\)</span>-values. The second-order derivative in the <span class="math inline">\(y\)</span>-direction can be represented as an <span class="math inline">\((n_y-2) \times (n_y-2)\)</span> matrix given by</p>
<p><span class="math display">\[
\mathbf{D}_y
=
\dfrac{1}{\Delta y^2}
\begin{bmatrix}
    -2  &amp; 1 \\
    1   &amp; -2 &amp; 1 \\
        &amp; 1 &amp; -2 &amp; 1 \\
        &amp;  &amp; \ddots &amp; \ddots &amp; \ddots \\
        &amp; &amp;   &amp;   1   &amp;   -2  &amp;   1   \\
        &amp; &amp;   &amp;       &amp;   1   &amp; -2
\end{bmatrix}
\]</span></p>
<p>where we excluded the points on the upper and lower boundaries as these are equal to zero owing to our choice of boundary conditions. Likewise, considering a single row of <span class="math inline">\(u\)</span> (i.e.&nbsp;fixing <span class="math inline">\(y\)</span> and considering different <span class="math inline">\(x\)</span>-values), the second-order derivative in the horizontal direction can be represented as an <span class="math inline">\((n_x - 2) \times (n_x -2)\)</span> matrix <span class="math inline">\(\mathbf{D}_x\)</span> with the same tridiagonal structure as <span class="math inline">\(\mathbf{D}_y\)</span>. Our problem can then be represented in a standard linear system form as</p>
<p><span class="math display">\[
\left( \mathbf{I}_{n_y} \otimes \mathbf{D}_x + \mathbf{D}_y \otimes \mathbf{I}_{n_x} \right) \mathrm{vec}(u) = -\mathrm{vec}(f),
\]</span></p>
<p>where <span class="math inline">\(\otimes\)</span> is the <a href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a>. If we were to explicitly construct it, this matrix would have <span class="math inline">\(n_x \times n_y\)</span> rows and likewise for the number of columns. For a discretization employing 512 points in each direction, that would be 260 100 columns and rows. Pretty big then, and completely intractable for standard direct linear solvers!</p>
</section>
<section id="the-jacobi-method-for-the-2d-poisson-equation" class="level3">
<h3 class="anchored" data-anchor-id="the-jacobi-method-for-the-2d-poisson-equation">The Jacobi method for the 2D Poisson equation</h3>
<p>Time to write the Jacobi update rule for our particular problem. Recall that our problem reads</p>
<p><span class="math display">\[
\dfrac{1}{\Delta x^2} \left( u_{i+1, j} + u_{i-1, j} + u_{i, j+1} + u_{i, j-1} - 4 u_{i, j} \right) = -f_{i, j}.
\]</span></p>
<p>On the left-hand side, the <span class="math inline">\(u_{ij}\)</span> term corresponds to the diagonal component while all the others are the off-diagonal ones. Following what we have written for the Jacobi method in matrix form, specializing for this equation leads to the following update rule</p>
<p><span class="math display">\[
u_{i, j}^{(t+1)} = \dfrac{1}{4} \left( \Delta x^2 \cdot f_{i, j} - u_{i+1, j}^{(t)} - u_{i-1, j}^{(t)} - u_{i, j+1}^{(t)} - u_{i, j-1}^{(t)} \right)
\]</span></p>
<p>where the superscript <span class="math inline">\(\cdot ^{(t)}\)</span> denotes the iteration number. This will be fairly simple to implement. Create two arrays, one to store the solution at iteration <span class="math inline">\(t\)</span> and the other one at iteration <span class="math inline">\(t+1\)</span>. Loop over the indices and update the <span class="math inline">\((i, j)\)</span>-th entries of the second table with the appropriate combination of values from the first one. Note that it is important to keep these two tables. If you were to have only one table and directly update its <span class="math inline">\((i, j)\)</span> entry, you would end-up with a different method: Gauss-Seidel. More on that in a later post (maybe).</p>
<p><strong>Convergence properties –</strong> The second-order accurate central finite-difference approximation <span class="math inline">\(\mathbf{L} = \mathbf{I}_{n_y} \otimes \mathbf{D}_x + \mathbf{D}_y \otimes \mathbf{I}_{n_x}\)</span> of the Laplace operator <span class="math inline">\(\nabla^2\)</span> is a symmetric negative definite matrix. Hence, <span class="math inline">\(-\mathbf{L}\)</span> is symmetric positive definite (and this is the reason for why there is a minus sign on the right-hand side of our problem if you wondered). It is easy to show moreover that <span class="math inline">\(-\mathbf{L}\)</span> satisfies the assumptions for Theorem n°2 to hold. Hence, after a sufficiently large number of iterations, the Jacobi method will converge to the actual solution of our linear system. But again, how fast?</p>
<p>As before, we can get some intuition by looking at the spectral radius of this matrix. I won’t go through the calculations (and I’ll assume <span class="math inline">\(n_x = n_y\)</span>), but we basically have</p>
<p><span class="math display">\[
\rho(\mathbf{I} + \mathbf{D}^{-1} \mathbf{L}) \simeq 1 - \dfrac{\pi^2}{2 n_x^2}.
\]</span></p>
<p>Using an increasing number of grid points to discretize our domain (that is considering a finer and finer mesh), the spectral radius of the iteration matrix gets closer and closer to unity. As a consequence, the Jacobi method requires more and more iterations to compute a reasonnably accurate solution. This poor scaling property is one of the reasons why it ain’t actually used nowadays in high-performance computing solvers. But this does not concern us here.</p>
</section>
</section>
<section id="let-fortran-shine" class="level2">
<h2 class="anchored" data-anchor-id="let-fortran-shine">Let <code>Fortran</code> shine!</h2>
<p>Alright! It’s time for what you all expected: the <code>Fortran</code> implementation. We’ll start with a simple translation to <code>Fortran</code> of the pseudo-code. This implementation will be our baseline. We will then incrementally improve it by using various tips and tricks with a particular constraint: use only standard-compliant <code>Fortran</code> code. I’ll try to explain the rationale behind every decision I make along the way. By the end of our journey, we’ll have a standard-compliant implementation which can naturally leverage multithreaded computations without having have to write a single openMP pragma. Performance-wise, we’ll end up with a 20x to 30x speed-up compared to our baseline implementation without every leaving the realm of <code>Fortran</code>. Too good to be true? Bare with me then!</p>
<section id="baseline-implementation" class="level3">
<h3 class="anchored" data-anchor-id="baseline-implementation">Baseline implementation</h3>
<p>Let us start with an almost verbatim translation of the pseudo-code to <code>Fortran</code>. In the rest, we will use <code>double precision</code> arithmetic. The <code>kind</code> parameter will be defined as</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">integer</span>, <span class="dt">parameter</span> <span class="dt">::</span> dp <span class="kw">=</span> <span class="fu">selected_real_kind</span>(<span class="dv">15</span>, <span class="dv">307</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is often considered to be a good practice in <code>Fortran</code> and guarantees a certain portability of the code across different compilers and platforms. Let us now turn our attention to the Jacobi kernel. Our textbook implementation is shown below.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">pure</span> <span class="kw">subroutine</span> textbook_kernel(nx, ny, u, v, b, dx)</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> nx, ny</span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(out)</span> <span class="dt">::</span> u(nx, ny)</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> v(nx, ny), b(nx, ny), dx</span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="dt">integer</span> <span class="dt">::</span> i, j</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">do</span> j <span class="kw">=</span> <span class="dv">2</span>, ny<span class="kw">-</span><span class="dv">1</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>        <span class="kw">do</span> i <span class="kw">=</span> <span class="dv">2</span>, nx<span class="kw">-</span><span class="dv">1</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>            u(i, j) <span class="kw">=</span> <span class="fl">0.25_dp</span><span class="kw">*</span>(b(i, j)<span class="kw">*</span>dx<span class="kw">**</span><span class="dv">2</span> <span class="kw">-</span> v(i<span class="kw">+</span><span class="dv">1</span>, j) <span class="kw">-</span> v(i<span class="kw">-</span><span class="dv">1</span>, j) <span class="kw">&amp;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>                                             <span class="kw">-</span> v(i, j<span class="kw">+</span><span class="dv">1</span>) <span class="kw">-</span> v(i, j<span class="kw">-</span><span class="dv">1</span>))</span>
<span id="cb2-11"><a href="#cb2-11"></a>        <span class="kw">enddo</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="kw">enddo</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">end subroutine</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>pure</code> keyword is here to tell the compiler that we guarantee this subroutine has no unintended side-effect. It is not technically mandatory, but it is also part of the good practices in <code>Fortran</code>. Hopefully, if we do things right, this kernel should be where we spend most of the computational time. To the actual solver now.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">function</span> textbook_solver(b, tol, maxiter) <span class="kw">result</span>(u)</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> b(:, :), tol</span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> maxiter</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="dt">real(dp)</span>, <span class="dt">allocatable</span> <span class="dt">::</span> u(:, :)</span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="co">! Internal variables</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="dt">integer</span> <span class="dt">::</span> nx, ny, i, j, iteration</span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="dt">real(dp)</span>, <span class="dt">allocatable</span> <span class="dt">::</span> v(:, :)</span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="dt">real(dp)</span> <span class="dt">::</span> dx, l2_norm</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="co">! Initialize variables</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    nx <span class="kw">=</span> <span class="fu">size</span>(b, <span class="dv">1</span>); ny <span class="kw">=</span> <span class="fu">size</span>(b, <span class="dv">2</span>); dx <span class="kw">=</span> <span class="fl">1.0_dp</span><span class="kw">/</span>(nx <span class="kw">-</span> <span class="dv">1</span>)</span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="kw">if</span> (nx <span class="op">/=</span> ny) <span class="kw">then</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>        error <span class="kw">stop</span> <span class="st">"Number of points in each direction need to be equal."</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="kw">endif</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>    <span class="kw">allocate</span> (u(nx, ny), source<span class="kw">=</span><span class="fl">0.0_dp</span>)</span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="kw">allocate</span> (v(nx, ny), source<span class="kw">=</span><span class="fl">0.0_dp</span>)</span>
<span id="cb3-17"><a href="#cb3-17"></a>    l2_norm <span class="kw">=</span> <span class="fl">1.0_dp</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>    iteration <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>    <span class="co">! Begining of the Jacobi iterative method.</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="kw">do</span> <span class="kw">while</span> ((iteration <span class="op">&lt;</span> maxiter) <span class="op">.and.</span> (l2_norm <span class="op">&gt;</span> tol))</span>
<span id="cb3-21"><a href="#cb3-21"></a>        <span class="co">! Jacobi iteration.</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>        <span class="kw">call</span> textbook_kernel(nx, ny, v, u, b, dx)</span>
<span id="cb3-23"><a href="#cb3-23"></a>        <span class="co">! Compute error norm.</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>        l2_norm <span class="kw">=</span> norm2(u <span class="kw">-</span> v)</span>
<span id="cb3-25"><a href="#cb3-25"></a>        <span class="co">! Update variable.</span></span>
<span id="cb3-26"><a href="#cb3-26"></a>        u <span class="kw">=</span> v</span>
<span id="cb3-27"><a href="#cb3-27"></a>        <span class="co">! Update iteration counter.</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>        iteration <span class="kw">=</span> iteration <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb3-29"><a href="#cb3-29"></a>    <span class="kw">end do</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"Textbook solver :"</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"    - Number of iterations :"</span>, iteration</span>
<span id="cb3-32"><a href="#cb3-32"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"    - l2-norm of the error :"</span>, l2_norm</span>
<span id="cb3-33"><a href="#cb3-33"></a><span class="kw">end function</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Even if you ain’t familiar with <code>Fortran</code>, the code should be quite readable. After having declared and initialized all of the required variables, the Jacobi method starts from Line 20 and proceeds in 3 steps:</p>
<ol type="1">
<li>Perform the Jacobi update by calling our textbook kernel.</li>
<li>Compute the 2-norm of the correction.</li>
<li>Update the current solution with its latest estimate.</li>
</ol>
<p>This loop keeps on going until the 2-norm of the correction is small enough to claim convergence. In all of our experiments, the tolerance is set to <span class="math inline">\(10^{-8}\)</span>.</p>
<p><strong>Performances –</strong> We will use 512 points in each direction with a uniform grid spacing and assume the initial guess to be the zero solution for all of our experiments. We thus have slightly more than a quarter million of unknowns, a reasonnably large linear system. The code is compiled using <code>gfortran 15.1</code> and the following options: <code>-O3 -march=native -mtune=native</code>. The table below summarizes some of the key computational metrics.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Solver</strong></th>
<th style="text-align: center;"><strong># of iterations</strong></th>
<th style="text-align: center;"><strong>Time to solution</strong></th>
<th style="text-align: center;"><strong>Speed-up w.r.t. baseline</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Textbook</td>
<td style="text-align: center;">128 395</td>
<td style="text-align: center;">58 s</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>Solving a linear system with a quarter million of unknowns in under one minute is quite impressive when you think about it. It is clearly orders of magnitude faster than if you were to do it by hand (and far less error-prone)! But is this the best we can do? You might be inclined to say <em>yes</em>. After all, our implementation is an almost verbatim translation of the pseudo-code and maths don’t lie. But that ain’t completely true though… When it comes to scientific computing, there are many streetfighting skills you can pick along the way to massively improve the computational performances of a given algorithm. So let’s start optimizing!</p>
</section>
<section id="you-shall-not-copy" class="level3">
<h3 class="anchored" data-anchor-id="you-shall-not-copy">You shall not copy!</h3>
<p>Our Jacobi kernel is so simple that there ain’t much room for improvement so let’s look at the solver itself starting with line 26</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb4-1"><a href="#cb4-1"></a>    u <span class="kw">=</span> v</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is the update of our current estimate of the solution with the one we’ve just computed. It essentially is a <code>copy</code> operation. Given how simple our Jacobi kernel is, it acutally takes almost as long as computing a Jacobi update. So let’s get rid of it by simply performing an additional call to the Jacobi kernel with the role of <code>u</code> and <code>v</code> being flipped.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">function</span> nocopy_solver(b, tol, maxiter) <span class="kw">result</span>(u)</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> b(:, :), tol</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> maxiter</span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="dt">real(dp)</span>, <span class="dt">allocatable</span> <span class="dt">::</span> u(:, :)</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="co">! Internal variables</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="dt">integer</span> <span class="dt">::</span> nx, ny, i, j, iteration</span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="dt">real(dp)</span>, <span class="dt">allocatable</span> <span class="dt">::</span> v(:, :)</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="dt">real(dp)</span> <span class="dt">::</span> dx, l2_norm</span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="co">! Initialize variables</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    nx <span class="kw">=</span> <span class="fu">size</span>(b, <span class="dv">1</span>); ny <span class="kw">=</span> <span class="fu">size</span>(b, <span class="dv">2</span>); dx <span class="kw">=</span> <span class="fl">1.0_dp</span><span class="kw">/</span>(nx <span class="kw">-</span> <span class="dv">1</span>)</span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="kw">if</span> (nx <span class="op">/=</span> ny) <span class="kw">then</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>        error <span class="kw">stop</span> <span class="st">"Number of points in each direction need to be equal."</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="kw">endif</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="kw">allocate</span> (u(nx, ny), source<span class="kw">=</span><span class="fl">0.0_dp</span>)</span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="kw">allocate</span> (v(nx, ny), source<span class="kw">=</span><span class="fl">0.0_dp</span>)</span>
<span id="cb5-17"><a href="#cb5-17"></a>    l2_norm <span class="kw">=</span> <span class="fl">1.0_dp</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>    iteration <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>    <span class="co">! Begining of the Jacobi iterative method.</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="kw">do</span> <span class="kw">while</span> ((iteration <span class="op">&lt;</span> maxiter) <span class="op">.and.</span> (l2_norm <span class="op">&gt;</span> tol))</span>
<span id="cb5-21"><a href="#cb5-21"></a>        <span class="co">! Jacobi iteration (no copy).</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>        <span class="kw">call</span> textbook_kernel(nx, ny, v, u, b, dx)</span>
<span id="cb5-23"><a href="#cb5-23"></a>        <span class="kw">call</span> textbook_kernel(nx, ny, u, v, b, dx)</span>
<span id="cb5-24"><a href="#cb5-24"></a>        <span class="co">! Compute error norm.</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>        l2_norm <span class="kw">=</span> norm2(u <span class="kw">-</span> v)</span>
<span id="cb5-26"><a href="#cb5-26"></a>        <span class="co">! Update iteration counter.</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>        iteration <span class="kw">=</span> iteration <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb5-28"><a href="#cb5-28"></a>    <span class="kw">end do</span></span>
<span id="cb5-29"><a href="#cb5-29"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"No-copy solver  :"</span></span>
<span id="cb5-30"><a href="#cb5-30"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"    - Number of iterations :"</span>, iteration</span>
<span id="cb5-31"><a href="#cb5-31"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"    - l2-norm of the error :"</span>, l2_norm</span>
<span id="cb5-32"><a href="#cb5-32"></a><span class="kw">end function</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Performances –</strong> Code-wise, very little has changed compared to our baseline implementation. The <code>nocopy_solver</code> slightly departs from the pseudo-code but is still as readable. Peformance-wise, it is a different story.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Solver</strong></th>
<th style="text-align: center;"><strong># of iterations</strong></th>
<th style="text-align: center;"><strong>Time to solution</strong></th>
<th style="text-align: center;"><strong>Speed-up w.r.t. baseline</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Textbook</td>
<td style="text-align: center;">128 395</td>
<td style="text-align: center;">58 s</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">No-copy</td>
<td style="text-align: center;">128 396</td>
<td style="text-align: center;">30 s</td>
<td style="text-align: center;">1.9</td>
</tr>
</tbody>
</table>
<p>This one-line change makes our solver compute the solution twice as fast! But don’t get too excited, it is somewhat expected if you think of it. A <code>copy</code> is roughly as expensive as computing a Jacobi update itself. As a consequence, in the time frame it took our baseline implementation to peform a Jacobi update followed by a copy, the <code>nocopy_solver</code> performed no copy (hence the name) but two updates. And boom, twice as fast. This is the first but probably most important take-away message:</p>
<blockquote class="blockquote">
<p><strong>Avoid copies like the plague and re-use intermediate results as much as possible.</strong></p>
</blockquote>
<p>This is not specific to <code>Fortran</code> and is true for pretty much any programming language you use.</p>
</section>
<section id="further-optimizations" class="level3">
<h3 class="anchored" data-anchor-id="further-optimizations">Further optimizations</h3>
<p>While the no-copy trick is fairly general, let us turn now to somewhat Jacobi-specific optimization tricks starting with the Jacobi kernel itself. Let <span class="math inline">\(v\)</span> be the current approximate solution and <span class="math inline">\(u\)</span> the new one being computed. Recall that the update rule is as follows</p>
<p><span class="math display">\[
    u_{i, j} = \dfrac{1}{4} \left( b_{i, j} \cdot \Delta x^2 - (v_{i+1, j} + v_{i-1, j} + v_{i, j+1} + v_{i, j-1}) \right)
\]</span></p>
<p>for all <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> corresponding to points in the interior of the computational domain. One crucial observation is that there are no dependencies between the entries of <span class="math inline">\(u\)</span>: they can be update in any abitrary order, not necessarily the lexicographic one. In particular, we could let the compiler decide on its own what is the most efficient way to do this update based on its internal mechanics. The 2008 standard introduced a particular construct conveying precisely this: the <code>do concurrent</code>. Below is the Jacobi kernel rewritten using this construct.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">pure</span> <span class="kw">subroutine</span> doconcurrent_kernel(nx, ny, u, v, b, dx)</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="kw">implicit</span> <span class="kw">none</span>(<span class="kw">external</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="dt">integer(ilp)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> nx, ny</span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(out)</span> <span class="dt">::</span> u(nx, ny)</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> v(nx, ny), b(nx, ny), dx</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="dt">integer</span> <span class="dt">::</span> i, j</span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="kw">do</span> concurrent(i<span class="kw">=</span><span class="dv">2</span>:nx <span class="kw">-</span> <span class="dv">1</span>, j<span class="kw">=</span><span class="dv">2</span>:ny <span class="kw">-</span> <span class="dv">1</span>)</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="co">! Jacobi update.</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>        u(i, j) <span class="kw">=</span> <span class="fl">0.25_dp</span><span class="kw">*</span>(b(i, j)<span class="kw">*</span>dx<span class="kw">**</span><span class="dv">2</span> <span class="kw">-</span> v(i <span class="kw">+</span> <span class="dv">1</span>, j) <span class="kw">-</span> v(i <span class="kw">-</span> <span class="dv">1</span>, j) <span class="kw">&amp;</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>                                         <span class="kw">-</span> v(i, j <span class="kw">+</span> <span class="dv">1</span>) <span class="kw">-</span> v(i, j <span class="kw">-</span> <span class="dv">1</span>))</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw">end do</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">end subroutine</span> doconcurrent_kernel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For now, it does not actually improve the computational performances of our kernel. For serial computations, it mostly is a syntactic sugar letting someone reading the code know that this loop could technically be computed in parallel with no problem. It might help the compiler optimize a bit, but the kernel being so simple I haven’t seen much changes. It’ll be different though once we go to multithreaded computations but that’s a story for slightly later.</p>
<p>The main source of computational improvement is located on line 25:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb7-1"><a href="#cb7-1"></a>    l2_norm <span class="kw">=</span> norm2(u<span class="kw">-</span>v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is nothing particularly wrong with this line. In practice however, the Jacobi method is quite slow to converge and computing the residual norm at every iteration incurs extra computational costs which are unecessary. We would be much better off by checking the residual only once in a while. We could replace it with</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb8-1"><a href="#cb8-1"></a>    <span class="kw">if</span> (<span class="bu">mod</span>(iteration, <span class="dv">1000</span>)) l2_norm <span class="kw">=</span> norm2(u <span class="kw">-</span> v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>or using the newest <code>do concurrent</code> construct</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">if</span> (<span class="bu">mod</span>(iteration, <span class="dv">1000</span>)) <span class="kw">then</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    l2_norm <span class="kw">=</span> <span class="fl">0.0_dp</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="kw">do</span> concurrent(i<span class="kw">=</span><span class="dv">2</span>:nx<span class="kw">-</span><span class="dv">1</span>, j<span class="kw">=</span><span class="dv">2</span>:ny<span class="kw">-</span><span class="dv">1</span>) reduce(<span class="kw">+</span>:l2_norm)</span>
<span id="cb9-4"><a href="#cb9-4"></a>        l2_norm <span class="kw">=</span> l2_norm <span class="kw">+</span> (u(i, j) <span class="kw">-</span> v(i, j))<span class="kw">**</span><span class="dv">2</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="kw">enddo</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    l2_norm <span class="kw">=</span> <span class="bu">sqrt</span>(l2_norm)</span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">endif</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Either way is fine, <code>norm2</code> is an intrinsic <code>Fortran</code> function and its implementation has already been optimized by the compiler vendors anyway. Checking the residual norm every 1000 iterations is arbitrary. It has been chosen out of simplicity considering that the method takes 128 000 iterations to converge for our particular problem. In practice, you might actually pass this as an extra argument to the solver to let the user decide. Here is the updated solver.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource fortran number-lines code-with-copy"><code class="sourceCode fortranfixed"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">function</span> doconcurrent_solver(b, tol, maxiter) <span class="kw">result</span>(u)</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">implicit</span> <span class="kw">none</span>(<span class="kw">external</span>)</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> b(:, :), tol</span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> maxiter</span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="dt">real(dp)</span>, <span class="dt">allocatable</span> <span class="dt">::</span> u(:, :)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="co">! Internal variables.</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="dt">integer</span> <span class="dt">::</span> nx, ny, i, j, iteration</span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="dt">real(dp)</span>, <span class="dt">allocatable</span> <span class="dt">::</span> v(:, :)</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="dt">real(dp)</span> <span class="dt">::</span> dx, l2_norm</span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="co">! Initialize variables</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    nx <span class="kw">=</span> <span class="fu">size</span>(b, <span class="dv">1</span>); ny <span class="kw">=</span> <span class="fu">size</span>(b, <span class="dv">2</span>); dx <span class="kw">=</span> <span class="fl">1.0_dp</span><span class="kw">/</span>(nx <span class="kw">-</span> <span class="dv">1</span>)</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="kw">if</span> (nx <span class="op">/=</span> ny) <span class="kw">then</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>        error <span class="kw">stop</span> <span class="st">"Number of points in each direction need to be equal."</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="kw">endif</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="kw">allocate</span> (u(nx, ny), source<span class="kw">=</span><span class="fl">0.0_dp</span>)</span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="kw">allocate</span> (v(nx, ny), source<span class="kw">=</span><span class="fl">0.0_dp</span>)</span>
<span id="cb10-17"><a href="#cb10-17"></a>    l2_norm <span class="kw">=</span> <span class="fl">1.0_dp</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>    iteration <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="kw">do</span> <span class="kw">while</span> ((iteration <span class="op">&lt;</span> maxiter) <span class="op">.and.</span> (l2_norm <span class="op">&gt;</span> tol))</span>
<span id="cb10-20"><a href="#cb10-20"></a>        <span class="co">! Jacobi kernel (no-copy).</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>        <span class="kw">call</span> doconcurrent_kernel(nx, ny, v, u, b, dx)</span>
<span id="cb10-22"><a href="#cb10-22"></a>        <span class="kw">call</span> doconcurrent_kernel(nx, ny, u, v, b, dx)</span>
<span id="cb10-23"><a href="#cb10-23"></a>        <span class="co">! Compute error norm.</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>        <span class="kw">if</span> (<span class="bu">mod</span>(iteration, <span class="dv">1000</span>) <span class="op">==</span> <span class="dv">0</span>) l2_norm <span class="kw">=</span> error_norm(u, v)</span>
<span id="cb10-25"><a href="#cb10-25"></a>        <span class="co">! Update iteration counter.</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>        iteration <span class="kw">=</span> iteration <span class="kw">+</span> <span class="dv">2</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>    <span class="kw">end do</span></span>
<span id="cb10-28"><a href="#cb10-28"></a>    l2_norm <span class="kw">=</span> error_norm(u, v) <span class="co">! Sanity check</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"Do-concurrent solver :"</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"    - Number of iterations :"</span>, iteration</span>
<span id="cb10-31"><a href="#cb10-31"></a>    <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"    - l2-norm of the error :"</span>, l2_norm</span>
<span id="cb10-32"><a href="#cb10-32"></a><span class="kw">end function</span></span>
<span id="cb10-33"><a href="#cb10-33"></a></span>
<span id="cb10-34"><a href="#cb10-34"></a><span class="kw">pure</span> <span class="dt">real(dp)</span> <span class="kw">function</span> error_norm(u, v) <span class="kw">result</span>(l2_norm)</span>
<span id="cb10-35"><a href="#cb10-35"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>    <span class="dt">real(dp)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> u(:, :), v(:, :)</span>
<span id="cb10-37"><a href="#cb10-37"></a>    <span class="dt">integer</span> <span class="dt">::</span> i, j</span>
<span id="cb10-38"><a href="#cb10-38"></a>    l2_norm <span class="kw">=</span> <span class="fl">0.0_dp</span></span>
<span id="cb10-39"><a href="#cb10-39"></a>    <span class="kw">do</span> concurrent(i<span class="kw">=</span><span class="dv">2</span>:<span class="fu">size</span>(u, <span class="dv">1</span>)<span class="kw">-</span><span class="dv">1</span>, j<span class="kw">=</span><span class="dv">2</span>:<span class="fu">size</span>(u, <span class="dv">2</span>)<span class="kw">-</span><span class="dv">1</span>) reduce(<span class="kw">+</span>:l2_norm)</span>
<span id="cb10-40"><a href="#cb10-40"></a>        l2_norm <span class="kw">=</span> l2_norm <span class="kw">+</span> (u(i, j) <span class="kw">-</span> v(i, j))<span class="kw">**</span><span class="dv">2</span></span>
<span id="cb10-41"><a href="#cb10-41"></a>    <span class="kw">end do</span></span>
<span id="cb10-42"><a href="#cb10-42"></a>    l2_norm <span class="kw">=</span> <span class="bu">sqrt</span>(l2_norm)</span>
<span id="cb10-43"><a href="#cb10-43"></a><span class="kw">end function</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Performances –</strong> Again, the new solver is just as readable as the previous ones. No big changes here, but look at the performances below!</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Solver</strong></th>
<th style="text-align: center;"><strong># of iterations</strong></th>
<th style="text-align: center;"><strong>Time to solution</strong></th>
<th style="text-align: center;"><strong>Speed-up w.r.t. baseline</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Textbook</td>
<td style="text-align: center;">128 395</td>
<td style="text-align: center;">58 s</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">No-copy</td>
<td style="text-align: center;">128 396</td>
<td style="text-align: center;">30 s</td>
<td style="text-align: center;">1.9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">do concurrent</td>
<td style="text-align: center;">129 002</td>
<td style="text-align: center;">16 s</td>
<td style="text-align: center;">3.6</td>
</tr>
</tbody>
</table>
<p>The new solver is 3 to 4 times faster than our baseline! This is quite remarkable given that we changed only a couple of lines compared to the original textbook implementation. Things are not always so clear cut for more complex algorithms, but still. And here is our second take-way:</p>
<blockquote class="blockquote">
<p><strong>Compute just what you need, not more.</strong></p>
</blockquote>
<p>Here, computing the residual norm for each iteration was clearly a non-negligible and non-necessary bottleneck. At this point, there is no more low-hanging fruit for optimization. You might think this is it. A 3.6x speed-up is good enough and you may call it a day. But you know what? There’s more. We can reach a 20x to 30x speed-up without changing anything else to the code!</p>
</section>
<section id="multithreaded-performances" class="level3">
<h3 class="anchored" data-anchor-id="multithreaded-performances">Multithreaded performances</h3>
<p>Computers these days tend to have built-in parallel computing capabilities. Yet, we haven’t leverage these so far. Let’s change that. I will not get into a discussion about openMP vs MPI or GPU offloading. I will keep things very practical instead. Remember when I said we can perform the Jacobi update in any <span class="math inline">\(i, j\)</span> order we want? The Jacobi update rule is embarassingly parallel. That is precisely what the <code>do concurrent</code> construct is conveying. And compilers can leverage this for increased computational performances. For our solver, it is as simple as changing the <code>gfortran</code> compilation options from</p>
<pre><code>-O3 -mtune=native -march=native</code></pre>
<p>to</p>
<pre><code>-O3 -mtune=native -march=native -ftree-parallelize-loops=n</code></pre>
<p>where <code>n</code> is the number of processes/threads to be used. And that’s it. Litterally. And look at these performances!</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Number of threads</strong></th>
<th style="text-align: center;"><strong>Time to solution</strong></th>
<th style="text-align: center;"><strong>Speed-up w.r.t. baseline</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">16 s</td>
<td style="text-align: center;">3.6</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">8.6 s</td>
<td style="text-align: center;">6.7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">4.1 s</td>
<td style="text-align: center;">14.1</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">2.1 s</td>
<td style="text-align: center;">27.6</td>
</tr>
</tbody>
</table>
<p>As promised, we finish with a linear solver computing the solution of a system with a quarter million of unknowns in less than 3 seconds and not a single openMP pragma or MPI call. The code is the <strong>exact same as before</strong>. The only thing that changed is the addition of the new compilation option. And that is enough to reach a 27x speed-up compared to our original textbook implementation!<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Pretty good considering we changed only a handful of lines of code and added only one extra compilation option, innit? There would be a lot more to say about the different parallel computing paradigms and the associated neaty greedy details, but this post is already sufficiently long as it is so I’ll stop right there. I’ll leave you with a cautionnary quote by the famous <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a> though</p>
<blockquote class="blockquote">
<p>The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.</p>
</blockquote>
<!--Include social share buttons-->
<!-- 
AddToAny check more: https://www.addtoany.com/buttons/for/website 
Using includes will make edits easier, will only need to add or remove button here if needed.
https://quarto.org/docs/authoring/includes.html
-->
<div class="a2a_kit a2a_kit_size_32 a2a_default_style">
<p><a class="a2a_dd" href="https://www.addtoany.com/share"></a> <a class="a2a_button_linkedin"></a> <a class="a2a_button_bluesky"></a> <a class="a2a_button_facebook"></a> <a class="a2a_button_copy_link"></a> <a class="a2a_button_email"></a></p>
</div>
<script async="" src="https://static.addtoany.com/menu/page.js"></script>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>We need to invert the matrix <span class="math inline">\(\mathbf{D}\)</span> at each iteration. While this operation requires <span class="math inline">\(\mathcal{O}(n^3)\)</span> flops for a general matrix, <span class="math inline">\(\mathbf{D}\)</span> here is diagonal. Hence, its inverse is straightforward to compute and only requires <span class="math inline">\(n\)</span> flops. Likewise, the matrix-vector product <span class="math inline">\(\mathbf{Rx}_t\)</span> requires in general <span class="math inline">\(\mathcal{O}(n^2)\)</span> flops. In most applications though, the matrix <span class="math inline">\(\mathbf{A}\)</span> is sparse and so is <span class="math inline">\(\mathbf{R}\)</span>, typically reducing the number of floating points operations down to <span class="math inline">\(\mathcal{O}(n)\)</span> as well. For a sparse linear system, each iteration of the Jacobi method hence requires <span class="math inline">\(\mathcal{O}(n)\)</span> flops. The question then is how many iterations does it take to converge?<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>If you run the code on your own computer, you may get different results as it depends on the number of cores you have, how fast they are, etc. But still, you should get pretty much the same trend.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("^(?:http:|https:)\/\/drganghe\.github\.io\/custom");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "loiseaujc/loiseaujc.github.io";
    script.dataset.repoId = "R_kgDOPsMNvw";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDOPsMNv84CvT6M";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<a href="http://www.github.com">Jean-Christophe Loiseau</a> ©
<script>document.write(new Date().getFullYear())</script>
</div>   
    <div class="nav-footer-center">
<p>Build on <a href="https://github.com/drganghe/quarto-academic-website-template">Quart Academic Website Template</a> adapted by <a href="http://drganghe.github.io">Dr.&nbsp;Gang He</a></p>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/drganghe/quarto-academic-website-template" target="_blank">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://bsky.app" target="_blank">
<p><i class="fa-brands fa-bluesky" aria-label="bluesky"></i></p>
</a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="../../posts.xml" target="_blank">
      <i class="bi bi-rss" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>